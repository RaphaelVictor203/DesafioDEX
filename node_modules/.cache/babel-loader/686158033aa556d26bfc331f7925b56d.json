{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _EventEmitter = _interopRequireDefault(require(\"./EventEmitter\"));\n\nvar _LiveQueryClient = _interopRequireDefault(require(\"./LiveQueryClient\"));\n\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\n/**\n * Copyright (c) 2015-present, Parse, LLC.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @flow\n */\n\n\nfunction open() {\n  var LiveQueryController = _CoreManager.default.getLiveQueryController();\n\n  LiveQueryController.open();\n}\n\nfunction close() {\n  var LiveQueryController = _CoreManager.default.getLiveQueryController();\n\n  LiveQueryController.close();\n}\n/**\n *\n * We expose three events to help you monitor the status of the WebSocket connection:\n *\n * <p>Open - When we establish the WebSocket connection to the LiveQuery server, you'll get this event.\n *\n * <pre>\n * Parse.LiveQuery.on('open', () => {\n *\n * });</pre></p>\n *\n * <p>Close - When we lose the WebSocket connection to the LiveQuery server, you'll get this event.\n *\n * <pre>\n * Parse.LiveQuery.on('close', () => {\n *\n * });</pre></p>\n *\n * <p>Error - When some network error or LiveQuery server error happens, you'll get this event.\n *\n * <pre>\n * Parse.LiveQuery.on('error', (error) => {\n *\n * });</pre></p>\n *\n * @class Parse.LiveQuery\n * @static\n *\n */\n\n\nvar LiveQuery = new _EventEmitter.default();\n/**\n * After open is called, the LiveQuery will try to send a connect request\n * to the LiveQuery server.\n *\n\n */\n\nLiveQuery.open = open;\n/**\n * When you're done using LiveQuery, you can call Parse.LiveQuery.close().\n * This function will close the WebSocket connection to the LiveQuery server,\n * cancel the auto reconnect, and unsubscribe all subscriptions based on it.\n * If you call query.subscribe() after this, we'll create a new WebSocket\n * connection to the LiveQuery server.\n *\n\n */\n\nLiveQuery.close = close; // Register a default onError callback to make sure we do not crash on error\n\nLiveQuery.on('error', function () {});\nvar _default = LiveQuery;\nexports.default = _default;\n\nfunction getSessionToken() {\n  var controller = _CoreManager.default.getUserController();\n\n  return controller.currentUserAsync().then(function (currentUser) {\n    return currentUser ? currentUser.getSessionToken() : undefined;\n  });\n}\n\nfunction getLiveQueryClient() {\n  return _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n}\n\nvar defaultLiveQueryClient;\nvar DefaultLiveQueryController = {\n  setDefaultLiveQueryClient: function setDefaultLiveQueryClient(liveQueryClient\n  /*: any*/\n  ) {\n    defaultLiveQueryClient = liveQueryClient;\n  },\n  getDefaultLiveQueryClient: function getDefaultLiveQueryClient()\n  /*: Promise*/\n  {\n    if (defaultLiveQueryClient) {\n      return Promise.resolve(defaultLiveQueryClient);\n    }\n\n    return getSessionToken().then(function (sessionToken) {\n      var liveQueryServerURL = _CoreManager.default.get('LIVEQUERY_SERVER_URL');\n\n      if (liveQueryServerURL && liveQueryServerURL.indexOf('ws') !== 0) {\n        throw new Error('You need to set a proper Parse LiveQuery server url before using LiveQueryClient');\n      } // If we can not find Parse.liveQueryServerURL, we try to extract it from Parse.serverURL\n\n\n      if (!liveQueryServerURL) {\n        var tempServerURL = _CoreManager.default.get('SERVER_URL');\n\n        var protocol = 'ws://'; // If Parse is being served over SSL/HTTPS, ensure LiveQuery Server uses 'wss://' prefix\n\n        if (tempServerURL.indexOf('https') === 0) {\n          protocol = 'wss://';\n        }\n\n        var host = tempServerURL.replace(/^https?:\\/\\//, '');\n        liveQueryServerURL = protocol + host;\n\n        _CoreManager.default.set('LIVEQUERY_SERVER_URL', liveQueryServerURL);\n      }\n\n      var applicationId = _CoreManager.default.get('APPLICATION_ID');\n\n      var javascriptKey = _CoreManager.default.get('JAVASCRIPT_KEY');\n\n      var masterKey = _CoreManager.default.get('MASTER_KEY'); // Get currentUser sessionToken if possible\n\n\n      defaultLiveQueryClient = new _LiveQueryClient.default({\n        applicationId: applicationId,\n        serverURL: liveQueryServerURL,\n        javascriptKey: javascriptKey,\n        masterKey: masterKey,\n        sessionToken: sessionToken\n      }); // Register a default onError callback to make sure we do not crash on error\n      // Cannot create these events on a nested way because of EventEmiiter from React Native\n\n      defaultLiveQueryClient.on('error', function (error) {\n        LiveQuery.emit('error', error);\n      });\n      defaultLiveQueryClient.on('open', function () {\n        LiveQuery.emit('open');\n      });\n      defaultLiveQueryClient.on('close', function () {\n        LiveQuery.emit('close');\n      });\n      return defaultLiveQueryClient;\n    });\n  },\n  open: function open() {\n    getLiveQueryClient().then(function (liveQueryClient) {\n      return liveQueryClient.open();\n    });\n  },\n  close: function close() {\n    getLiveQueryClient().then(function (liveQueryClient) {\n      return liveQueryClient.close();\n    });\n  },\n  subscribe: function subscribe(query\n  /*: any*/\n  )\n  /*: EventEmitter*/\n  {\n    var subscriptionWrap = new _EventEmitter.default();\n    getLiveQueryClient().then(function (liveQueryClient) {\n      if (liveQueryClient.shouldOpen()) {\n        liveQueryClient.open();\n      }\n\n      var promiseSessionToken = getSessionToken(); // new event emitter\n\n      return promiseSessionToken.then(function (sessionToken) {\n        var subscription = liveQueryClient.subscribe(query, sessionToken); // enter, leave create, etc\n\n        subscriptionWrap.id = subscription.id;\n        subscriptionWrap.query = subscription.query;\n        subscriptionWrap.sessionToken = subscription.sessionToken;\n        subscriptionWrap.unsubscribe = subscription.unsubscribe; // Cannot create these events on a nested way because of EventEmiiter from React Native\n\n        subscription.on('open', function () {\n          subscriptionWrap.emit('open');\n        });\n        subscription.on('create', function (object) {\n          subscriptionWrap.emit('create', object);\n        });\n        subscription.on('update', function (object) {\n          subscriptionWrap.emit('update', object);\n        });\n        subscription.on('enter', function (object) {\n          subscriptionWrap.emit('enter', object);\n        });\n        subscription.on('leave', function (object) {\n          subscriptionWrap.emit('leave', object);\n        });\n        subscription.on('delete', function (object) {\n          subscriptionWrap.emit('delete', object);\n        });\n        subscription.on('close', function (object) {\n          subscriptionWrap.emit('close', object);\n        });\n        subscription.on('error', function (object) {\n          subscriptionWrap.emit('error', object);\n        });\n      });\n    });\n    return subscriptionWrap;\n  },\n  unsubscribe: function unsubscribe(subscription\n  /*: any*/\n  ) {\n    getLiveQueryClient().then(function (liveQueryClient) {\n      return liveQueryClient.unsubscribe(subscription);\n    });\n  },\n  _clearCachedDefaultClient: function _clearCachedDefaultClient() {\n    defaultLiveQueryClient = null;\n  }\n};\n\n_CoreManager.default.setLiveQueryController(DefaultLiveQueryController);","map":null,"metadata":{},"sourceType":"script"}